# 누가 카이사르를 화나게 했을까 - Dreamhack
## Challenge Info
- Date: 2025
- CTF Name: Dreamhack
- Category: crypto
- Difficulty (subjective): easy
- Points: 1
- Provided Files: 문제설명.txt, papers(dir)
- tools:
## Brief Description
카이사르가 화가 났다.  
누가 그의 암호 방식이 너무 쉽다고 소문을 퍼트렸기 때문이다.  
화가 난 카이사르는 플래그가 들어있던 종이를 찢어버렸다.  
찢어진 종이들 가운데에서 암호문을 찾아 복호화하여 플래그를 찾아야 한다.  

복호화를 위한 힌트는 두가지이다.  
1. 카이사르 암호화에 사용된 문자와 그 순서는 다음과 같다 => "bcdefghimnrswy0123456789{_}"
2. 플래그의 형식을 참고하자. => `플래그 형식은 안 보인다..`
## Initial Analysis
총 2024개의 파일이 존재하며, 이 파일 중 몇 개를 열어본 결과 카이사르 암호화에 사용되지 않은 문자를 가진 파일들이 다수 존재했다. 따라서 복호화 이전에 2024개의 파일 중에서 유의미한 데이터를 수집하는 과정이 필요하다.  
``` python
# find encoded text
characters = 'bcdefghimnrswy0123456789{_}'
words = list(characters)
data = ''
FILEPATH = '화난카이사르'
fileName = ''
for i in range(1, 2025) :
    fileName = FILEPATH + '\\papers\\' + str(i) + '.txt'
    with open(fileName, 'r') as file :
        tmp = file.read()
        if any(word in tmp for word in words) :
            data += tmp + ' ' 

fileName = FILEPATH + '\\data.txt'
with open(fileName, 'w') as file : # 문자열이 길 것으로 예상해서 파일에 저장했는데, 생각보다 짧으니 그냥 출력해도 무관하다.
    file.write(data)
```
우선 해당 코드를 통해서 2024개의 파일 중 유요한 문자들만 선별했으며, 페이지(파일)의 순서 또한 FLAG의 순서와 상관없이 무작위일 수 있으므로 공백를 추가해 섹션을 나누었다.  
### Result  
``` plain text
"nd627{ nwd08d7 s48w 93_ b_bd n5dy0 m r"
```
## PoC(Poof of Concept)
### solve.py
``` python
# decoding
characters = 'bcdefghimnrswy0123456789{_}' # cnt: 27
encoded = 'nd627{ nwd08d7 s48w 93_ b_bd n5dy0 m r' # get from the data.txt file
decoded = ''
for key in range(27) :
    for char in encoded :
        if char == ' ' :
            decoded += ' '
        else :
            idx = (characters.index(char) + key) % 27
            decoded += characters[idx]
    # if decoded.count('{') == 1 and decoded.count('}') == 1: # 필터링
    print(f"Key {key}: {decoded}")
    decoded = ''
```
찾은 유효한 문자들에 27개의 키를 전수 조사하는 방식으로 카이사르 암호 복호화를 진행했다. (해당 문제에서 총 27개의 문자가 카이사르 암호에 사용되었음)  
FLAG 형식 특성상 `중괄호('{}')`의 여닫는 괄호가 한 번씩 나오는 경우만 필터링하여 출력하면, FLAG 형식에 맞지 않는 무의미한 평문들을 상당 수 제거할 수 있다.  
### result
``` sh
Key 0: nd627{ nwd08d7 s48w 93_ b_bd n5dy0 m r
Key 1: re738_ rye19e8 w59y {4} c}ce r6e01 n s
Key 2: sf849} s0f2{f9 y6{0 _5b dbdf s7f12 r w
Key 3: wg95{b w1g3_g{ 07_1 }6c eceg w8g23 s y
Key 4: yh{6_c y2h4}h_ 18}2 b7d fdfh y9h34 w 0
Key 5: 0i_7}d 03i5bi} 29b3 c8e gegi 0{i45 y 1
Key 6: 1m}8be 14m6cmb 3{c4 d9f hfhm 1_m56 0 2
Key 7: 2nb9cf 25n7dnc 4_d5 e{g igin 2}n67 1 3
Key 8: 3rc{dg 36r8erd 5}e6 f_h mhmr 3br78 2 4
Key 9: 4sd_eh 47s9fse 6bf7 g}i nins 4cs89 3 5
Key 10: 5we}fi 58w{gwf 7cg8 hbm rmrw 5dw9{ 4 6
Key 11: 6yfbgm 69y_hyg 8dh9 icn snsy 6ey{_ 5 7
Key 12: 70gchn 7{0}i0h 9ei{ mdr wrw0 7f0_} 6 8
Key 13: 81hdir 8_1bm1i {fm_ nes ysy1 8g1}b 7 9
Key 14: 92iems 9}2cn2m _gn} rfw 0w02 9h2bc 8 {
Key 15: {3mfnw {b3dr3n }hrb sgy 1y13 {i3cd 9 _
Key 16: _4ngry _c4es4r bisc wh0 2024 _m4de { }
Key 17: }5rhs0 }d5fw5s cmwd yi1 3135 }n5ef _ b
Key 18: b6siw1 be6gy6w dnye 0m2 4246 br6fg } c
Key 19: c7wmy2 cf7h07y er0f 1n3 5357 cs7gh b d
Key 20: d8yn03 dg8i180 fs1g 2r4 6468 dw8hi c e
Key 21: e90r14 eh9m291 gw2h 3s5 7579 ey9im d f
Key 22: f{1s25 fi{n3{2 hy3i 4w6 868{ f0{mn e g
Key 23: g_2w36 gm_r4_3 i04m 5y7 979_ g1_nr f h
Key 24: h}3y47 hn}s5}4 m15n 608 {8{} h2}rs g i
Key 25: ib4058 irbw6b5 n26r 719 _9_b i3bsw h m
Key 26: mc5169 mscy7c6 r37s 82{ }{}c m4cwy i n
```
27개의 평문 결과가 궁금해서 필터링은 진행하지 않았다. 결과 중 의미 있는 문자열이 존재하는 평문을 찾아 순서를 적절히 조합하면 FLAG를 구할 수 있다.  